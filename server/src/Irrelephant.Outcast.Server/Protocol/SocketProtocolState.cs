using Irrelephant.Outcast.Protocol;
using Irrelephant.Outcast.Protocol.Messages;
using Irrelephant.Outcast.Server.Configuration;
using Microsoft.Extensions.Options;

namespace Irrelephant.Outcast.Server.Protocol;

internal enum ProtocolReadState
{
    ReadingTlvHeader,
    ReadingTlvPayload,
}

public class SocketProtocolState(IOptions<OutcastNetworkingOptions> options)
{
    /// <summary>
    /// Time of last networking operation performed by this socket.
    /// </summary>
    private DateTimeOffset _lastActivity = DateTimeOffset.MinValue;

    /// <summary>
    /// Received messages that need to processed.
    /// </summary>
    public Queue<Message> ReceivedMessages { get; } = new();

    /// <summary>
    /// Messages generated by the protocol that need to be sent.
    /// </summary>
    public Queue<Message> MessagesToSend { get; } = new();

    /// <summary>
    /// Resets the state machine to be used again.
    /// </summary>
    public void Reset()
    {
        _lastActivity = DateTimeOffset.MinValue;
    }

    /// <summary>
    /// Buffer for TLV header reading.
    /// </summary>
    private readonly byte[] _tlvHeaderBuffer = new byte[TlvHeader.Size];

    /// <summary>
    /// Amount of bytes read from the TLV header.
    /// </summary>
    private int _tlvHeaderWriteIndex;

    /// <summary>
    /// TLV header of the message currently being read.
    /// </summary>
    private TlvHeader? _completeTlvHeader;

    /// <summary>
    /// Resizable buffer for reading of the message payload.
    /// </summary>
    private byte[] _messagePayloadBuffer = new byte[options.Value.BufferSize];

    /// <summary>
    /// Amount of bytes read from the TLV message payload.
    /// </summary>
    private int _tlvPayloadWriteIndex = 0;

    /// <summary>
    /// Current state of reading of the TLV message.
    /// </summary>
    private ProtocolReadState _readState = ProtocolReadState.ReadingTlvHeader;

    public void ProcessRead(Memory<byte> buffer, int receivedBytes, bool isAsync = true)
    {
        UpdateLastActivity(isAsync);
        int processedBytes = 0;

        do
        {
            if (_readState == ProtocolReadState.ReadingTlvHeader)
            {
                processedBytes += ReadTlvHeader(buffer, receivedBytes, processedBytes);
            }

            if (_readState == ProtocolReadState.ReadingTlvPayload)
            {
                processedBytes += ReadTlvPayload(buffer, receivedBytes, processedBytes);
            }

        } while (processedBytes < receivedBytes);
    }

    private int ReadTlvHeader(Memory<byte> buffer, int receivedBytes, int processedBytes)
    {
        var bytesAvailableToRead = Math.Min(
            TlvHeader.Size - _tlvHeaderWriteIndex,
            receivedBytes - processedBytes
        );
        var bufferReadRange = processedBytes..(processedBytes + bytesAvailableToRead);
        buffer[bufferReadRange].CopyTo(_tlvHeaderBuffer.AsMemory(_tlvHeaderWriteIndex..));
        _tlvHeaderWriteIndex += bytesAvailableToRead;

        if (_tlvHeaderWriteIndex == TlvHeader.Size)
        {
            _completeTlvHeader = TlvHeader.Unpack(_tlvHeaderBuffer);
            _tlvHeaderWriteIndex = 0;
            _readState = ProtocolReadState.ReadingTlvPayload;
        }

        return bytesAvailableToRead;
    }

    private int ReadTlvPayload(Memory<byte> buffer, int receivedBytes, int processedBytes)
    {
        if (_completeTlvHeader is null)
        {
            throw new InvalidOperationException("Can't read message payload until the header was read!");
        }

        var payloadBytesAvailableToRead = Math.Min(
            _completeTlvHeader.Value.MessageLength - _tlvPayloadWriteIndex,
            receivedBytes - processedBytes
        );
        var bufferReadRange = processedBytes..(processedBytes + payloadBytesAvailableToRead);

        if (payloadBytesAvailableToRead > _messagePayloadBuffer.Length)
        {
            GrowInternalBuffer(minNewSize: payloadBytesAvailableToRead);
        }

        buffer[bufferReadRange].CopyTo(_messagePayloadBuffer.AsMemory(_tlvPayloadWriteIndex..));
        _tlvPayloadWriteIndex += payloadBytesAvailableToRead;

        if (_tlvPayloadWriteIndex == _completeTlvHeader.Value.MessageLength)
        {
            var message = new TlvMessage(
                _completeTlvHeader.Value,
                _messagePayloadBuffer.AsMemory(.._completeTlvHeader.Value.MessageLength)
            );

            ReceivedMessages.Enqueue(options.Value.MessageCodec.Decode(message));
            _readState = ProtocolReadState.ReadingTlvHeader;
            _tlvPayloadWriteIndex = 0;
        }

        return payloadBytesAvailableToRead;
    }

    private void GrowInternalBuffer(int minNewSize)
    {
        var nextPowerOfTwoSize = (int)Math.Pow(2, Math.Ceiling(Math.Log(minNewSize) / Math.Log(2)));
        if (nextPowerOfTwoSize > options.Value.MaxResizableBufferSize)
        {
            throw new InvalidOperationException(
                $"Refusing to grow internal buffer past configured max size of {options.Value.MaxResizableBufferSize}."
            );
        }
        var newBuffer = new byte[nextPowerOfTwoSize];
        _messagePayloadBuffer.CopyTo(newBuffer, 0);
        _messagePayloadBuffer = newBuffer;
    }

    private void UpdateLastActivity(bool isAsync)
    {
        // Sync operations were already pending on the socket, so no need to update activity time
        // in case of a sync operation.
        if (isAsync)
        {
            _lastActivity = DateTimeOffset.UtcNow;
        }
    }
}
